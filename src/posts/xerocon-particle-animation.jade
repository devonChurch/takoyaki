extends ../partials/post.jade

block pageData
    -
        page = {
            template: 'post',
            heading: 'Xerocon particle animation',
            type: 'Experiment',
            date: generateDate({
                year: 2015,
                month: 12,
                day: 11
            }),
            images: {
                type: '2upEqual',
                data: [
                    {src: 'xerocon-particle-animation-start', extension: 'jpg', alt: 'Initial particle locations positioned using an exponential displacement algorithm'},
                    {src: 'xerocon-particle-animation-end', extension: 'jpg', alt: 'Constrained particles revealing the Xerocon pin icon'}
                ]
            },
            technology: [
                'Webpack',
                'ES6 (Transpired using Babel)',
                'Canvas',
                'SASS'
            ],
            more: [
                { heading: 'Code Pen', link: 'http://codepen.io/DevonChurch/full/zrBBZa/', local: false},
                { heading: 'Git Hub', link: 'https://github.com/devonChurch/blueberry-danish', local: false}
            ]
        } //- page ]

block content
    :markdown
        This canvas experiment was conceived during a meeting whilst in my current role at [Xero](https://www.xero.com). A new aesthetic was pitched for their flagship global conference [Xerocon](https://www.xero.com/xerocon/london/), which used particles to illustrate the event logo (a pin icon). However, it became apparent that someone was manually placing all of the particle instances within each icon design. This was a job for procedural generation and with a little more effort we could play with the particle parameters to create some interesting animations.
        
        Canvas was the obvious choice to produce this execution, which relied heavily on performance due to the manipulation of so many particles. I rewrote the particle trajectory script several times because of rendering performance, where dynamically calculating each degree of offset on a per pixel basis was rather intense for 1000 particle instances. Instead, I calculated a lot of the math on load and referenced the stored data with a series of randomisation calculations. This gave the same effect as my original implementation but with much less overhead.
